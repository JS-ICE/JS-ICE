// functions for JS-ICE
//A. Salij 5.23.2018 (andrewsalij@gmail.com) 

//converts the point data type in jmol into arrays of the 3 coordinates, indexed x,y,z 

symClickStatus = ""; //NEW GLOBAL VARIABLE!

//Converts a point "{x y z}" into an array "[x,y,z]"
function pointToArray(pointt){
	var pointt = ""+pointt+"" 
	var coordinateArray = []
	var totalChars = pointt.length
	for (var i = 0; i < totalChars;i++){
		if (pointt[i] == "{"){
			pointt[i] = " "
		}
		if (pointt[i] == "}"){
			pointt[i] = " "
		}
	}
	var elementString  = ""
	for (var i = 0; i <= totalChars;i++){
		if (pointt[i] == " " || pointt[i] == "\t"){
			if (elementString != " " && elementString != ""){
				coordinateArray.push(elementString)
			}
			elementString = ""
			
		}
		else{
			elementString += pointt[i]
		}
	}
	return coordinateArray
}

//Converts an array "[x,y,z]" into a point "{x y z}" 
function arrayToPoint(xyzArray){
	pointt = "{"+xyzArray[0]+","+xyzArray[1]+","+xyzArray[2]+"}"
	return pointt 
}

// gets and returns the symmetry operation vector (as in "x,y,z" for identity are so forth) names 
function readSymmetryVectors() {
	var symopVectorArray = [];
	if (_M.fileSymmetryOperations)
		{symopVectorArray = _M.fileSymmetryOperations 
	}
	else {
		var symopCharArray = _M.getProperty("spacegroupInfo.symmetryInfo")
		var totalChars = symopCharArray.length
		var allElementsArray = []
		var elementCounter = 1
		for (var i = 1; i <= totalChars;i++){
			if (symopCharArray[i] == "\t" || symopCharArray[i] == " "){
				allElementsArray[elementCounter] = elementString
				var elementString = ""
				elementCounter += 1 
			}
			if (symopCharArray[i] != "\t" && symopCharArray[i] != " "){
				elementString += symopCharArray[i]
			}
		}
		var vectorCounter = 1
		var totalElements = allElementsArray.length
		for (var i = 1; i <= elementCounter; i++) {
			var elementString = ""+allElementsArray[i]
			var strLength  = elementString.length
			for (var j = 1; j<= strLength; j++) {
				if  (elementString[j] == ","){
					symopVectorArray[vectorCounter] = allElementsArray[i];
					vectorCounter += 1 
					break
				}
			}
		}
	}

	return symopVectorArray
}

// returns the number of elements in the subgroup
function getSubgroupCount(symop) {
	var p0 = {1.414,3.1415,2.718}
	var p = p0;
	var n = 1;
	for (n = 1; n < 7; n++) {
		var p1 = all.symop(symop, p);
		if (p1.distance(p0) < 0.001)
			return n;
		p = p1;
	}
	return 0;
}
 

// returns the points given after performing a symmetry operation a chosen number of times (one point per operation)
function getSymmetricAtomArray(symopSelected,pointt,iterations){

	if (iterations < 0)
  		iterations = getSubgroupCount(symopSelected) - 1;

	if (!pointt){
		return []
	}
	if (pointt == {}){
		return []
	}
	var symAtomArray = [];

	for (var i = 1; i<= iterations;i++) {
		if (i=1){

			var output = {visible}.symop(symopSelected,pointt)

			}
		if (i>= 2) {

			var output = {visible}.symop(symopSelected,symAtomArray[i-1])

		}	

	}
	symAtomArray[i] = output; 
	return symAtomArray 
}

//draws narrow arrows as opposed to the thicker, shorter arrows provided by the default draw symop command 
function drawCleanSymmetryAxisVectors(axisFactor){
	//draw sym_axis* off 
	point1 = $sym_rotvector1[0]
	point2 = $sym_rotvector1[1]
	point3 = $sym_rotvector2[0]
	point4 = $sym_rotvector2[1]
	point2 = (point2-point1)*axisFactor
	point4 = (point4-point3)*axisFactor
	draw sym_rotvector* off 
	draw ID "sym_axis1" vector @point1 @point2
	draw ID "sym_axis2" vector @point3 @point4 
} 

//adds new atom to current model
function appendNewAtom(elementName, point) {
	model last;
	assign atom @elementName @point //appends new atom, connected to a base atom in original structure 

} 

function appendNewAtomPoint(elementID, elementName, pointt){
	model last;
	if (!pointt){
		return 0
	}
	if (pointt == {}){
		return 0 
	}
	if (!elementName || elementName == ""){
		var elementName = "H" 
	}
	if (!elementID || elementID = ""){
		var elementID  = "defaultID"
	}
	var x = @1.element
	@1.element = elementName
	var col = @1.color
	@1.element = x 
	draw ID @elementID radius .3 @pointt color @col //to update radius size and color to be akin to chosen element 
}

//provides all the output of all available symops of the current model upon a given point 
function getSymmetryAtomArrayAllSymops(point){
	getProperty spacegroupInfo.symmetryInfo
	symopArray = readSymmetryVectors()
	symAtomArrayAllSymops = []
	numberSymops = symopArray.length
	for (var i = 1;i <= numberSymops; i++){
		currentSymop = symopArray[i]
		symmetryAppliedPoint = all.symop(currentSymop,point)
		symAtomArrayAllSymops[i] = symmetryAppliedPoint
	}
	return symAtomArrayAllSymops
}

//provides the closest point on a line designated by some axis draw object to some selected point if said point is within some distance 
function bindToVectorConstraint(vectorDrawObjectID,selectedPoint,errorDistance){
	var vectorPointer = ""+vectorDrawObjectID+"" //IMPORTANT: this is how to designate pointers in jmol
	var startPoint = $ @vectorPointer[0]
	var endPoint = $ @vectorPointer[1]
	startPoint = $sym_rotvector1[0]// for demonstration bc pointers aren't working
	endPoint = $sym_rotvector1[1]//
	var constrainedPoint = intersection(startPoint,endPoint-startPoint,selectedPoint) //second input into intersection is a vector from first point
	var selectedPointToNewPointDistance = selectedPoint.distance(constrainedPoint)
	if (selectedPointToNewPointDistance > errorDistance){
		return selectedPoint 
	}
	else{
		return constrainedPoint 
	}
}

//provides the closest point on a plane designated by some draw object to some selected point if
//said point is within some distance 
function bindToPlaneConstraint(planeDrawObjectID, selectedPoint, errorDistance){
	var planePointer = ""+planeDrawObjectID+""
	var constrainedPoint = intersection(selectedPoint,planePointer)
	var selectedPointToNewPointDistance = @selectedPoint.distance(constrainedPoint)
	if (selectedPointToNewPointDistance > errorDistance){
		return selectedPoint 
	}
	else{
		return constrainedPoint 
	}
}

//Takes some point and outputs the closest point on some arbitrary sphere 
function bindToSphereConstraint(sphereCenterPoint,sphereRadius,selectedPoint){
	var c = sphereCenterPoint
	var r = sphereRadius
	var s = selectedPoint
	var fromCenterVectorUnit = (s-c)/(s-c)
	var pointOnSphere = c+fromCenterVectorUnit*r
	return pointOnSphere
}

// provides an array of the symops that do not change the position of a given atom--n is total number of symops to check  
function findInvariantSymOps(atom,n){
	var symopArray = readSymmetryVectors()
	//print "symopArray:"+symopArray
	//print "atom:"+atom
	var invariantSymopsArray = []
	if (atom == null){
		return invariantSymopsArray
	}
    var invariantSymopsCounter = 0 
    var identityPoint = symop("x,y,z",atom)
    var error = .01
	for (var i  = 1; i<= n; i++){
		output = symop(symopArray[i],atom)
		//print [output,identityPoint,i,symopArray[i],atom] 
		if(distance(identityPoint,output)<error){
			//print "symop found"
			invariantSymopsCounter = invariantSymopsCounter+1
			invariantSymopsArray[invariantSymopsCounter] = symopArray[i]
		}
	}	
	//print "invariantSymopsArray:"+invariantSymopsArray
	return invariantSymopsArray
}	


//Provides x and y screen coordinates of mouse 
function storeScreenXY(_X,_Y){
	var x = _X
	var y = _Y
	return [x,y]
}

function moveToSXYMatch(_X,_Y,screenDistanceBound){
	//print "starting program"
	var sxyzArray = {visible}.sxyz.all
	var x = _X
	var y = _Y
	//print "click:"+_X
	var error = screenDistanceBound
	var sx = x
	var sy = y 
	nAtoms = {visible}.size 
	for (var i = 1; i<nAtoms+1; i++){
		//print "i:"+i
		currentPoint = sxyzArray[i]
		currentPointArray = pointToArray(currentPoint)
		ax = currentPointArray[1]
		//print "ax:"+ax
		ay = currentPointArray[2] 
		//print "ay:"+ay	
		dist = ((ax-x)**2+(ay-y)**2)**(.5)
		if (dist <= error){
			sx = ax
			sy = ay 
			break;
		}
	}
	//print "sx:"+sx
	//print "sy:"+sy
	return [sx,sy]	
}

//only works for points with a given index (e.g. atoms) 
function sXYtoXY(sxyArray){
	var nAtoms = {visible}.size
	var sxyzArray = {visible}.sxyz.all
	var x = sxyArray[1]
	var y = sxyArray[2]
	for (var i = 1; i<nAtoms+1; i++){
		var currentPoint = sxyzArray[i]
		var currentPointArray = pointToArray(currentPoint)
		if (currentPointArray[1] == sxyArray[1]){
			if (currentPointArray[2] == sxyArray[2]){
				pointXY = {visible}.xyz.all[i]
				pointXYArray = pointToArray(pointXY)
				//print pointXYArray
				x = pointXYArray[1]
				y = pointXYArray[2]
			}
		}	
	}
	return [x,y]
}

//Transforms a click to the closest point on a sphere defiend by some center and some radius 
function clickToPoint(centerXYZ,radiusAngstroms,_X,_Y){
	//var screenUnitsToAngstromsRatioArray = screenUnitsToAngstroms()
	if (centerXYZ == {}){
		return 0 
	}
	var r = radiusAngstroms 
	var centerPointXYZ = pointToArray(centerXYZ)
	var cXYZ = centerXYZ
	var cSXYZ = point(cXYZ,true)
	var p0XYZ = point(point(_X,_Y,cSXYZ.z),false)
	//print "p0XYZ:"+p0XYZ
	var pTempXYZ = point(point(_X,_Y,cSXYZ.z+1000),false)
	var normVect = (p0XYZ-pTempXYZ)/(p0XYZ-pTempXYZ)
	//print "normVect:"+normVect
	var d = distance(p0XYZ,cXYZ)
	if (d > r){
		return 0
	}
	var dz = (r**2-d**2)**(.5)
	var pXYZ = p0XYZ+normVect*dz
	//print "pXYZ:"+pXYZ
	return pXYZ
}


//needs more testing
function drawVector(vectorID,vectorStart,vectorEnd){
	var vectorIDString = ""+vectorID+""
	var vectorStartString = ""+vectorStart+""
	var vectorEndString = ""+vectorEnd+""
	draw @vectorIDString @vectorstartString @vectorEndString
}


//Draws every symmetry operation given some array of Jones-Faithful representations of symmetry operations 
function drawAllSymops(symopArray,centerPoint){
	for (var i=1;i<=symopArray.size;i++){
		var symopID = "symop"+i
		//print "symopID: "+ symopID
		var currentSymop = "'"+symopArray[i]+"'"
		draw ID @symopID symop @currentSymop @centerPoint
	}
}





