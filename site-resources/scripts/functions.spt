// functions for JS-ICE
//A. Salij 4.10.2018 (salij1@stolaf.edu----->andrewsalij@gmail.com) 

//converts the point data type in jmol into arrays of the 3 coordinates, indexed x,y,z 

symClickStatus = ""; //NEW GLOBAL VARIABLE!

//Converts a point "{x y z}" into an array "[x,y,z]"
function pointToArray(pointt){
	var pointt = ""+pointt+"" 
	var coordinateArray = []
	var totalChars = pointt.length
	for (var i = 0; i < totalChars;i++){
		if (pointt[i] == "{"){
			pointt[i] = " "
		}
		if (pointt[i] == "}"){
			pointt[i] = " "
		}
	}
	var elementString  = ""
	for (var i = 0; i <= totalChars;i++){
		if (pointt[i] == " " || pointt[i] == "\t"){
			if (elementString != " " && elementString != ""){
				coordinateArray.push(elementString)
			}
			elementString = ""
			
		}
		else{
			elementString += pointt[i]
		}
	}
	return coordinateArray
}

// gets and returns the symmetry operation vector (as in "x,y,z" for identity are so forth) names 
function readSymmetryVectors() {
	var symopVectorArray = [];
	if (_M.fileSymmetryOperations)
		{symopVectorArray = _M.fileSymmetryOperations 
	}
	else {
		var symopCharArray = _M.getProperty("spacegroupInfo.symmetryInfo")
		var totalChars = symopCharArray.length
		var allElementsArray = []
		var elementCounter = 1
		for (var i = 1; i <= totalChars;i++){
			if (symopCharArray[i] == "\t" || symopCharArray[i] == " "){
				allElementsArray[elementCounter] = elementString
				var elementString = ""
				elementCounter += 1 
			}
			if (symopCharArray[i] != "\t" && symopCharArray[i] != " "){
				elementString += symopCharArray[i]
			}
		}
		var vectorCounter = 1
		var totalElements = allElementsArray.length
		for (var i = 1; i <= elementCounter; i++) {
			var elementString = ""+allElementsArray[i]
			var strLength  = elementString.length
			for (var j = 1; j<= strLength; j++) {
				if  (elementString[j] == ","){
					symopVectorArray[vectorCounter] = allElementsArray[i];
					vectorCounter += 1 
					break
				}
			}
		}
	}

	return symopVectorArray
}


 

// returns the points given after performing a symmetry operation a chosen number of times (one point per operation)
function getSymmetricAtomArray(symopSelected,pointt,iterations){
	var symAtomArray = [];
	for (var i = 1; i<= iterations;i++) {
		if (i=1){
			var output = all.symop(symopSelected,pointt)
			symAtomArray[i] = output; 
			}
		if (i>= 2) {
			var output = all.symop(symopSelected,symAtomArray[i-1])
			symAtomArray[i] = output;
		}	

	}
	return symAtomArray 
}

//draws narrow arrows as opposed to the thicker, shorter arrows provided by the default draw symop command 
function drawCleanSymmetryAxisVectors(axisFactor){
	//draw sym_axis* off 
	//draw symop @symOperation
	point1 = $sym_rotvector1[0]
	point2 = $sym_rotvector1[1]
	point3 = $sym_rotvector2[0]
	point4 = $sym_rotvector2[1]
	point2 = (point2-point1)*axisFactor
	point4 = (point4-point3)*axisFactor
	draw sym_rotvector* off 
	draw ID "sym_axis1" vector @point1 @point2
	draw ID "sym_axis2" vector @point3 @point4 
} 

//adds new atom to current model
function appendNewAtom(elementName, point) {
	model last;
	assign atom @elementName @point //appends new atom, connected to a base atom in original structure 

} 

//provides all the output of all available symops of the current model upon a given point 
function getSymmetryAtomArrayAllSymops(point){
	getProperty spacegroupInfo.symmetryInfo
	symopArray = readSymmetryVectors()
	symAtomArrayAllSymops = []
	numberSymops = symopArray.length
	for (var i = 1;i <= numberSymops; i++){
		currentSymop = symopArray[i]
		symmetryAppliedPoint = all.symop(currentSymop,point)
		symAtomArrayAllSymops[i] = symmetryAppliedPoint
	}
	return symAtomArrayAllSymops
}

//Not fully tested
//provides the closest point on a line designated by some axis draw object to some selected point if said point is within some distance 
function bindToVectorConstraint(vectorDrawObjectID,selectedPoint,errorDistance){
	var vectorPointer = ""+vectorDrawObjectID+"" //IMPORTANT: this is how to designate pointers in jmol
	var startPoint = $ @vectorPointer[0]
	var endPoint = $ @vectorPointer[1]
	startPoint = $sym_rotvector1[0]// for demonstration bc pointers aren't working
	endPoint = $sym_rotvector1[1]//
	var constrainedPoint = intersection(startPoint,endPoint-startPoint,selectedPoint) //second input into intersection is a vector from first point
	var selectedPointToNewPointDistance = selectedPoint.distance(constrainedPoint)
	if (selectedPointToNewPointDistance > errorDistance){
		return selectedPoint 
	}
	else{
		return constrainedPoint 
	}
}

//provides the closest point on a plane designated by some draw object to some selected point if
//said point is within some distance 
function bindToPlaneConstraint(planeDrawObjectID, selectedPoint, errorDistance){
	var planePointer = ""+planeDrawObjectID+""
	var constrainedPoint = intersection(selectedPoint,planePointer)
	var selectedPointToNewPointDistance = @selectedPoint.distance(constrainedPoint)
	if (selectedPointToNewPointDistance > errorDistance){
		return selectedPoint 
	}
	else{
		return constrainedPoint 
	}
}

function bindToSphereConstraint(sphereCenterPoint,sphereRadius,selectedPoint,errorDistance){
	//details need filling--talk to Dr. Hanson about documentation on circle intersection
	//var constrainedPoint = intersection() NEEDS FILLING 
	var contrainedPoint = {0 0 0} //PLACEHOLDER
	var selectedPointToNewPointDistance = @selectedPoint.distance(constrainedPoint)
	if (selectedPointToNewPointDistance > errorDistance){
		return selectedPoint 
	}
	else{
		return constrainedPoint 
	}
}

// provides an array of the symops that do not change the position of a given atom--n is total number of symops to check  
function findInvariantSymOps(atom,n){
	var symopArray = readSymmetryVectors()
	//print "symopArray:"+symopArray
	//print "atom:"+atom
	var invariantSymopsArray = []
	if (atom == null){
		return invariantSymopsArray
	}
    var invariantSymopsCounter = 0 
    var identityPoint = symop("x,y,z",atom)
    var error = .01
	for (var i  = 1; i<= n; i++){
		output = symop(symopArray[i],atom)
		print [output,identityPoint,i,symopArray[i],atom] 
		if(distance(identityPoint,output)<error){
			//print "symop found"
			invariantSymopsCounter = invariantSymopsCounter+1
			invariantSymopsArray[invariantSymopsCounter] = symopArray[i]
		}
	}	
	//print "invariantSymopsArray:"+invariantSymopsArray
	return invariantSymopsArray
}	

//Unused 
//function setSymopClickBinding(){
//	bind "LEFT+click" "+:pickSymops"
//}

//Provides x and y screen coordinates of mouse 
function storeScreenXY(_X,_Y){
	var x = _X
	var y = _Y
	return [x,y]
}


function moveToSXYMatch(_X,_Y,screenDistanceBound){
	//print "starting program"
	var sxyzArray = {visible}.sxyz.all
	var x = _X
	var y = _Y
	//print "click:"+_X
	var error = screenDistanceBound
	var sx = x
	var sy = y 
	nAtoms = {visible}.size 
	for (var i = 1; i<nAtoms+1; i++){
		print "i:"+i
		currentPoint = sxyzArray[i]
		currentPointArray = pointToArray(currentPoint)
		ax = currentPointArray[1]
		//print "ax:"+ax
		ay = currentPointArray[2] 
		//print "ay:"+ay	
		dist = ((ax-x)**2+(ay-y)**2)**(.5)
		if (dist <= error){
			sx = ax
			sy = ay 
			break;
		}
	}
	//print "sx:"+sx
	//print "sy:"+sy
	return [sx,sy]	
}
//only works for points with a given index (e.g. atoms) 
function sXYtoXY(sxyArray){
	var nAtoms = {visible}.size
	var sxyzArray = {visible}.sxyz.all
	var x = sxyArray[1]
	var y = sxyArray[2]
	for (var i = 1; i<nAtoms+1; i++){
		var currentPoint = sxyzArray[i]
		var currentPointArray = pointToArray(currentPoint)
		if (currentPointArray[1] == sxyArray[1]){
			if (currentPointArray[2] == sxyArray[2]){
				pointXY = {visible}.xyz.all[i]
				pointXYArray = pointToArray(pointXY)
				print pointXYArray
				x = pointXYArray[1]
				y = pointXYArray[2]
			}
		}	
	}
	return [x,y]
}

//Transforms a click to the closest point on a sphere defiend by some center and some radius 
function clickToPoint(centerXYZ,radiusAngstroms,_X,_Y){
	//var screenUnitsToAngstromsRatioArray = screenUnitsToAngstroms()
	var r = radiusAngstroms //for now, r will be in screen coords 
	var centerPointXYZ = pointToArray(centerXYZ)
	var cXYZ = centerXYZ
	var cSXYZ = point(cXYZ,true)
	var p0XYZ = point(point(_X,_Y,cSXYZ.z),false)
	var pTempXYZ = point(point(_X,_Y,cSXYZ.z+1000),false)
	var normVect = (p0XYZ-pTempXYZ)/(p0XYZ-pTempXYZ)
	var d = distance(p0XYZ,cXYZ)
	if (d > r){
		return 0
	}
	var dz = (r**2-d**2)**(.5)
	var pXYZ = p0XYZ+normVect*dz
	return pXYZ
}

//needs more testing
function drawVector(vectorID,vectorStart,vectorEnd){
	var vectorIDString = ""+vectorID+""
	var vectorStartString = ""+vectorStart+""
	var vectorEndString = ""+vectorEnd+""
	draw @vectorIDString @vectorstartString @vectorEndString
}

//Sets a messagecallback for left clicking
//This handling is not being used. Instead, JQuery is providing schema for general click handling. a
function bindLeftClickKeyEvent(){
	bind "LEFT+click" "+:set MessageCallback 'leftClick';print 'leftClick'"
}

//Draws every symmetry operation given some array of Jones-Faithful representations of symmetry operations 
function drawAllSymops(symopArray,centerPoint){
	for (var i=1;i<=symopArray.size;i++){
		var symopID = "symop"+i
		draw ID @symopID symop @i @centerPoint
	}
}

//Unused
// gets and returns the symmetry operation names (e.g. "identity") 
//not really necessary for current functionality but nice to have 
//only functional in jsmol as jsice cannot read spacegroupInfo.operations
function readSymmetryNames() {
	var allSymopInfo = _M.getProperty("spacegroupInfo.operations");
	var numSymops = allSymopInfo.length;
	var symopNameArray = [];
	for (var i = 1; i<= numSymops;i++){
		var symopCurrent = allSymopInfo[i];
		var currentName = symopCurrent[3];
		symopNameArray[i] = currentName;
	}
	return symopNameArray
}

