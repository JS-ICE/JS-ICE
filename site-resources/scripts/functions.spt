
// functions for JS-ICE
// gets and returns the symmetry operation names (e.g. "identity") 
//not really necessary for current functionality but nice to have 
//only functional in jsmol as jsice cannot read spacegroupInfo.operations

function pointToArray(pointt){
	var pointt = ""+pointt+"" 
	var coordinateArray = []
	var totalChars = pointt.length
	for (var i = 0; i < totalChars;i++){
		if (pointt[i] == "{"){
			pointt[i] = " "
		}
		if (pointt[i] == "}"){
			pointt[i] = " "
		}
	}
	var elementString  = ""
	for (var i = 0; i <= totalChars;i++){
		if (pointt[i] == " " || pointt[i] == "\t"){
			if (elementString != " " && elementString != ""){
				coordinateArray.push(elementString)
			}
			elementString = ""
			
		}
		else{
			elementString += pointt[i]
		}
	}
	return coordinateArray
}
//Unused
function readSymmetryNames() {
	var allSymopInfo = _M.getProperty("spacegroupInfo.operations");
	var numSymops = allSymopInfo.length;
	var symopNameArray = [];
	for (var i = 1; i<= numSymops;i++){
		var symopCurrent = allSymopInfo[i];
		var currentName = symopCurrent[3];
		symopNameArray[i] = currentName;
	}
	return symopNameArray
}
// gets and returns the symmetry operation vector (as in "x,y,z" for identity are so forth) names 
function readSymmetryVectors() {
	var symopVectorArray = [];
	if (_M.fileSymmetryOperations)
		{symopVectorArray = _M.fileSymmetryOperations 
	}
	else {
		var symopCharArray = _M.getProperty("spacegroupInfo.symmetryInfo")
		var totalChars = symopCharArray.length
		var allElementsArray = []
		var elementCounter = 1
		for (var i = 1; i <= totalChars;i++){
			if (symopCharArray[i] == "\t" || symopCharArray[i] == " "){
				allElementsArray[elementCounter] = elementString
				var elementString = ""
				elementCounter += 1 
			}
			if (symopCharArray[i] != "\t" && symopCharArray[i] != " "){
				elementString += symopCharArray[i]
			}
		}
		var vectorCounter = 1
		var totalElements = allElementsArray.length
		for (var i = 1; i <= elementCounter; i++) {
			var elementString = ""+allElementsArray[i]
			var strLength  = elementString.length
			for (var j = 1; j<= strLength; j++) {
				if  (elementString[j] == ","){
					symopVectorArray[vectorCounter] = allElementsArray[i];
					vectorCounter += 1 
					break
				}
			}
		}
	}

	return symopVectorArray
}
 

// returns the points given after performing a symmetry operation a chosen number of times (one point per operation)

function getSymmetricAtomArray(symopSelected,pointt,iterations){
	var symAtomArray = [];
	for (var i = 1; i<= iterations;i++) {
		if (i=1){
			var output = all.symop(symopSelected,pointt)
			symAtomArray[i] = output; 
			}
		if (i>= 2) {
			var output = all.symop(symopSelected,symAtomArray[i-1])
			symAtomArray[i] = output;
		}	

	}
	return symAtomArray 
}
// adds new element by appending an element and then deleting the newly-created bond
// needs significant work such that elements that should be strings are strings and that code runs out of javascript and not just jmol script editor
// A.S. 10.24.18 
//
//function dragAtomConstrained
// set picking dragatom 
//
//p1 = $draw_object_name[0]  ; p2 = $draw_object_name[1]
function drawCleanSymmetryAxisVectors(symOperation, axisFactor){
	draw sym_axis* off 
	draw symop @symOperation
	point1 = $sym_rotvector1[0]
	point2 = $sym_rotvector1[1]
	point3 = $sym_rotvector2[0]
	point4 = $sym_rotvector2[1]
	point1 = point1*axisFactor
	point3 = point3*axisFactor
	draw s* off 
	draw ID "sym_axis1" vector @point2 @point1 
	draw ID "sym_axis2" vector @point4 @point3
} 

function appendNewAtom(elementName, point) {
	model last;
	assign atom @elementName @point //appends new atom, connected to a base atom in original structure 

} 

function getSymmetryAtomArrayAllSymops(point){
	getProperty spacegroupInfo.symmetryInfo
	symopArray = readSymmetryVectors()
	symAtomArrayAllSymops = []
	numberSymops = symopArray.length
	for (var i = 1;i <= numberSymops; i++){
		currentSymop = symopArray[i]
		symmetryAppliedPoint = all.symop(currentSymop,point)
		symAtomArrayAllSymops[i] = symmetryAppliedPoint
	}
	return symAtomArrayAllSymops
}

//IDEA: constraint menu
//UNTESTED
//Many of the below functions are outlines for future functions 
function bindToVectorConstraint(vectorDrawObjectID,selectedPoint,errorDistance){
	startPoint = $@vectorDrawObjectID[0]
	endPoint = $@vectorDrawObjectID[1] 
	constrainedPoint = intersection(startPoint,endPoint,selectedPoint) 
	if (selectedPointToNewPointDistance > errorDistance){
		return selectedPoint 
	}
	else{
		return contrainedPoint 
	}
}

function bindToPlaneConstraint(planeDrawObjectID, selectedPoint, errorDistance){
	constrainedPoint = intersection(selectedPoint,planeDrawObjectID)
	selectedPointToNewPointDistance = @selectedPoint.distance(planeDrawObjectID)
	if (selectedPointToNewPointDistance > errorDistance){
		return selectedPoint 
	}
	else{
		return constrainedPoint 
	}
}

